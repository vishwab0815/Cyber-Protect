/**
 * VirusTotal File Scanning Service
 * Upload and scan files using VirusTotal's multi-engine scanner
 */

export interface VirusTotalFileResult {
  isMalicious: boolean;
  detectionRatio: string; // "45/70"
  detections: number;
  totalEngines: number;
  malwareNames: string[];
  threatCategories: string[];
  confidence: number;
  scanDate: Date;
  permalink?: string;
}

export class VirusTotalFileService {
  private static readonly API_BASE_URL = 'https://www.virustotal.com/api/v3';
  private static readonly API_KEY = process.env.VIRUSTOTAL_API_KEY || '';

  /**
   * Scan file using VirusTotal
   */
  static async scanFile(fileBuffer: Buffer, fileName: string): Promise<VirusTotalFileResult> {
    if (!this.API_KEY) {
      console.warn('VirusTotal API key not configured');
      return this.getDefaultResult();
    }

    try {
      // Submit file for scanning
      const fileHash = await this.uploadFile(fileBuffer, fileName);

      // Wait for scan completion
      await this.waitForScan(fileHash);

      // Get scan report
      const report = await this.getReport(fileHash);

      return this.parseFileReport(report);
    } catch (error) {
      console.error('VirusTotal file scan error:', error);
      return this.getDefaultResult();
    }
  }

  /**
   * Check file hash without uploading
   */
  static async checkHash(hash: string): Promise<VirusTotalFileResult | null> {
    if (!this.API_KEY) return null;

    try {
      const report = await this.getReport(hash);
      return this.parseFileReport(report);
    } catch {
      return null;
    }
  }

  /**
   * Upload file to VirusTotal
   */
  private static async uploadFile(buffer: Buffer, fileName: string): Promise<string> {
    const formData = new FormData();
    const blob = new Blob([new Uint8Array(buffer)]);
    formData.append('file', blob, fileName);

    const response = await fetch(`${this.API_BASE_URL}/files`, {
      method: 'POST',
      headers: {
        'x-apikey': this.API_KEY,
      },
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`VirusTotal upload failed: ${response.statusText}`);
    }

    const data = await response.json();
    return data.data.id;
  }

  /**
   * Wait for scan to complete
   */
  private static async waitForScan(analysisId: string, maxWait = 60000): Promise<void> {
    const startTime = Date.now();

    while (Date.now() - startTime < maxWait) {
      const response = await fetch(`${this.API_BASE_URL}/analyses/${analysisId}`, {
        headers: {
          'x-apikey': this.API_KEY,
        },
      });

      const data = await response.json();

      if (data.data.attributes.status === 'completed') {
        return;
      }

      // Wait 5 seconds before checking again
      await new Promise(resolve => setTimeout(resolve, 5000));
    }

    throw new Error('Scan timeout');
  }

  /**
   * Get scan report
   */
  private static async getReport(fileId: string): Promise<any> {
    const response = await fetch(`${this.API_BASE_URL}/files/${fileId}`, {
      headers: {
        'x-apikey': this.API_KEY,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to get report: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Parse VirusTotal file report
   */
  private static parseFileReport(report: any): VirusTotalFileResult {
    const stats = report.data?.attributes?.last_analysis_stats || {};
    const results = report.data?.attributes?.last_analysis_results || {};

    const malicious = stats.malicious || 0;
    const suspicious = stats.suspicious || 0;
    const undetected = stats.undetected || 0;
    const harmless = stats.harmless || 0;

    const totalEngines = malicious + suspicious + undetected + harmless;
    const detections = malicious + suspicious;

    // Extract malware names
    const malwareNames: string[] = [];
    const threatCategories = new Set<string>();

    Object.values(results).forEach((result: any) => {
      if (result.category === 'malicious' || result.category === 'suspicious') {
        if (result.result) {
          malwareNames.push(result.result);

          // Categorize threat type
          const resultLower = result.result.toLowerCase();
          if (resultLower.includes('ransom')) threatCategories.add('ransomware');
          else if (resultLower.includes('trojan')) threatCategories.add('trojan');
          else if (resultLower.includes('worm')) threatCategories.add('worm');
          else if (resultLower.includes('rootkit')) threatCategories.add('rootkit');
          else if (resultLower.includes('backdoor')) threatCategories.add('backdoor');
          else if (resultLower.includes('adware')) threatCategories.add('adware');
          else if (resultLower.includes('spyware')) threatCategories.add('spyware');
          else threatCategories.add('malware');
        }
      }
    });

    const confidence = totalEngines > 0 ? Math.round((detections / totalEngines) * 100) : 0;

    return {
      isMalicious: detections > 0,
      detectionRatio: `${detections}/${totalEngines}`,
      detections,
      totalEngines,
      malwareNames: malwareNames.slice(0, 10), // Top 10
      threatCategories: Array.from(threatCategories),
      confidence,
      scanDate: new Date(),
      permalink: report.data?.links?.self,
    };
  }

  /**
   * Get default result when API unavailable
   */
  private static getDefaultResult(): VirusTotalFileResult {
    return {
      isMalicious: false,
      detectionRatio: '0/0',
      detections: 0,
      totalEngines: 0,
      malwareNames: [],
      threatCategories: [],
      confidence: 0,
      scanDate: new Date(),
    };
  }
}
