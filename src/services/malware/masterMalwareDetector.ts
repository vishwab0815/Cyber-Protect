/**
 * Master Malware Detector
 * Orchestrates all malware detection techniques for comprehensive analysis
 */

import { FileAnalyzer } from './fileAnalyzer';
import { DocumentAnalyzer } from './documentAnalyzer';
import { ScriptAnalyzer } from './scriptAnalyzer';
import { VirusTotalFileService } from './virusTotalFile';
import { ThreatLevel } from '@prisma/client';

export interface ComprehensiveMalwareAnalysis {
  fileName: string;
  fileSize: number;
  fileType: string;
  threatLevel: ThreatLevel;
  isMalicious: boolean;
  riskScore: number;
  confidence: number;
  indicators: string[];
  recommendations: string[];
  analysisLayers: {
    staticAnalysis?: any;
    documentAnalysis?: any;
    scriptAnalysis?: any;
    virusTotal?: any;
  };
  summary: {
    totalDetections: number;
    signatureMatches: number;
    behavioralFlags: number;
    externalEngineDetections: number;
  };
  scanDuration: number;
  timestamp: Date;
}

export class MasterMalwareDetector {
  /**
   * Comprehensive file malware analysis
   */
  static async analyzeFile(
    fileBuffer: Buffer,
    fileName: string,
    userId?: string
  ): Promise<ComprehensiveMalwareAnalysis> {
    const startTime = Date.now();
    const allIndicators: string[] = [];
    const analysisLayers: any = {};
    let maxRiskScore = 0;
    let totalDetections = 0;

    const fileSize = fileBuffer.length;
    const fileType = this.detectFileType(fileName);

    // Layer 1: Static File Analysis (Always run)
    try {
      const staticAnalysis = await FileAnalyzer.analyzeFile(fileBuffer, fileName, userId);
      analysisLayers.staticAnalysis = staticAnalysis;
      allIndicators.push(...staticAnalysis.indicators);
      maxRiskScore = Math.max(maxRiskScore, staticAnalysis.riskScore);
      totalDetections += staticAnalysis.detections.signatureMatches;
    } catch (error) {
      console.error('Static analysis failed:', error);
    }

    // Layer 2: Document-Specific Analysis
    if (this.isDocument(fileName)) {
      try {
        const docAnalysis = await DocumentAnalyzer.analyzeDocument(fileBuffer, fileName);
        analysisLayers.documentAnalysis = docAnalysis;
        allIndicators.push(...docAnalysis.indicators);
        maxRiskScore = Math.max(maxRiskScore, docAnalysis.riskScore);

        if (docAnalysis.isMalicious) {
          totalDetections++;
        }
      } catch (error) {
        console.error('Document analysis failed:', error);
      }
    }

    // Layer 3: Script-Specific Analysis
    if (this.isScript(fileName)) {
      try {
        const scriptAnalysis = await ScriptAnalyzer.analyzeScript(fileBuffer, fileName);
        analysisLayers.scriptAnalysis = scriptAnalysis;
        allIndicators.push(...scriptAnalysis.indicators);
        maxRiskScore = Math.max(maxRiskScore, scriptAnalysis.riskScore);

        if (scriptAnalysis.isMalicious) {
          totalDetections++;
        }
      } catch (error) {
        console.error('Script analysis failed:', error);
      }
    }

    // Layer 4: VirusTotal Multi-Engine Scan (if available and file < 32MB)
    if (fileSize < 32 * 1024 * 1024) {
      try {
        const vtAnalysis = await VirusTotalFileService.scanFile(fileBuffer, fileName);
        analysisLayers.virusTotal = vtAnalysis;

        if (vtAnalysis.isMalicious) {
          allIndicators.push(
            `VirusTotal: ${vtAnalysis.detections}/${vtAnalysis.totalEngines} engines detected threats`
          );
          allIndicators.push(...vtAnalysis.malwareNames.slice(0, 3));
        }

        maxRiskScore = Math.max(maxRiskScore, vtAnalysis.confidence);
        totalDetections += vtAnalysis.detections;
      } catch (error) {
        console.error('VirusTotal analysis failed:', error);
      }
    }

    // Calculate comprehensive risk score
    const riskScore = this.calculateOverallRiskScore(analysisLayers);

    // Determine threat level
    const threatLevel = this.determineThreatLevel(riskScore);

    // Determine if malicious
    const isMalicious =
      riskScore >= 60 ||
      (analysisLayers.virusTotal?.detections || 0) >= 3 ||
      totalDetections >= 2;

    // Calculate confidence
    const confidence = this.calculateConfidence(analysisLayers);

    // Generate recommendations
    const recommendations = this.generateRecommendations(
      threatLevel,
      isMalicious,
      analysisLayers
    );

    // Build summary
    const summary = {
      totalDetections,
      signatureMatches: analysisLayers.staticAnalysis?.detections?.signatureMatches || 0,
      behavioralFlags: analysisLayers.staticAnalysis?.detections?.behavioralFlags || 0,
      externalEngineDetections: analysisLayers.virusTotal?.detections || 0,
    };

    const scanDuration = Date.now() - startTime;

    return {
      fileName,
      fileSize,
      fileType,
      threatLevel,
      isMalicious,
      riskScore: Math.min(riskScore, 100),
      confidence,
      indicators: this.deduplicateIndicators(allIndicators),
      recommendations,
      analysisLayers,
      summary,
      scanDuration,
      timestamp: new Date(),
    };
  }

  /**
   * Calculate overall risk score from all layers
   */
  private static calculateOverallRiskScore(layers: any): number {
    let score = 0;
    let layerCount = 0;

    // Static analysis: 30% weight
    if (layers.staticAnalysis) {
      score += layers.staticAnalysis.riskScore * 0.3;
      layerCount++;
    }

    // Document analysis: 25% weight
    if (layers.documentAnalysis) {
      score += layers.documentAnalysis.riskScore * 0.25;
      layerCount++;
    }

    // Script analysis: 25% weight
    if (layers.scriptAnalysis) {
      score += layers.scriptAnalysis.riskScore * 0.25;
      layerCount++;
    }

    // VirusTotal: 40% weight (most trusted)
    if (layers.virusTotal) {
      const vtScore = layers.virusTotal.confidence;
      score += vtScore * 0.4;
      layerCount++;

      // Boost score if multiple engines detected
      if (layers.virusTotal.detections >= 5) {
        score += 20;
      }
    }

    return Math.min(score, 100);
  }

  /**
   * Calculate confidence score
   */
  private static calculateConfidence(layers: any): number {
    let confidence = 50;

    // Each layer adds confidence
    if (layers.staticAnalysis) confidence += 15;
    if (layers.documentAnalysis) confidence += 10;
    if (layers.scriptAnalysis) confidence += 10;
    if (layers.virusTotal) confidence += 25; // VirusTotal adds most confidence

    return Math.min(confidence, 100);
  }

  /**
   * Determine threat level
   */
  private static determineThreatLevel(riskScore: number): ThreatLevel {
    if (riskScore >= 80) return 'CRITICAL';
    if (riskScore >= 60) return 'HIGH';
    if (riskScore >= 40) return 'MEDIUM';
    if (riskScore >= 20) return 'LOW';
    return 'SAFE';
  }

  /**
   * Generate recommendations
   */
  private static generateRecommendations(
    threatLevel: ThreatLevel,
    isMalicious: boolean,
    layers: any
  ): string[] {
    const recommendations: string[] = [];

    if (threatLevel === 'CRITICAL') {
      recommendations.push('CRITICAL THREAT: Delete this file immediately');
      recommendations.push('DO NOT execute or open this file under any circumstances');
      recommendations.push('Isolate the system if file was already opened');
      recommendations.push('Scan entire system with updated antivirus');
      recommendations.push('Change all passwords if system was compromised');
    } else if (threatLevel === 'HIGH') {
      recommendations.push('HIGH RISK: Quarantine this file');
      recommendations.push('Do not execute without expert security analysis');
      recommendations.push('Submit to security team for investigation');
      recommendations.push('Monitor system for unusual activity');
    } else if (threatLevel === 'MEDIUM') {
      recommendations.push('MEDIUM RISK: Exercise extreme caution');
      recommendations.push('Verify file source before opening');
      recommendations.push('Scan in isolated sandbox environment');
      recommendations.push('Consider submitting to VirusTotal for verification');
    } else if (threatLevel === 'LOW') {
      recommendations.push('Low risk detected - verify source');
      recommendations.push('Use caution when opening files from unknown sources');
    } else {
      recommendations.push('File appears safe based on current analysis');
      recommendations.push('Always verify file sources and authenticity');
    }

    // Layer-specific recommendations
    if (layers.documentAnalysis?.hasMacros) {
      recommendations.push('Document contains macros - do NOT enable unless from trusted source');
    }

    if (layers.scriptAnalysis?.suspiciousPatterns?.obfuscation) {
      recommendations.push('Script is obfuscated - strong indicator of malicious intent');
    }

    if (layers.virusTotal?.detections >= 10) {
      recommendations.push(`${layers.virusTotal.detections} antivirus engines detected this as malware`);
    }

    return recommendations;
  }

  /**
   * Detect file type category
   */
  private static detectFileType(fileName: string): string {
    const ext = fileName.toLowerCase().match(/\.([^.]+)$/)?.[1];

    const categories: { [key: string]: string[] } = {
      executable: ['exe', 'dll', 'sys', 'scr', 'bat', 'cmd', 'com', 'pif', 'msi'],
      script: ['js', 'vbs', 'ps1', 'py', 'sh', 'bash', 'pl', 'rb'],
      document: ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'pdf', 'rtf', 'odt', 'ods'],
      archive: ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'],
      image: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg'],
    };

    for (const [category, extensions] of Object.entries(categories)) {
      if (ext && extensions.includes(ext)) {
        return category;
      }
    }

    return 'unknown';
  }

  /**
   * Check if file is a document
   */
  private static isDocument(fileName: string): boolean {
    const docExtensions = ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.pdf', '.rtf', '.docm', '.xlsm', '.pptm'];
    return docExtensions.some(ext => fileName.toLowerCase().endsWith(ext));
  }

  /**
   * Check if file is a script
   */
  private static isScript(fileName: string): boolean {
    const scriptExtensions = ['.js', '.vbs', '.ps1', '.py', '.sh', '.bash', '.bat', '.cmd', '.pl', '.rb'];
    return scriptExtensions.some(ext => fileName.toLowerCase().endsWith(ext));
  }

  /**
   * Deduplicate indicators
   */
  private static deduplicateIndicators(indicators: string[]): string[] {
    return Array.from(new Set(indicators));
  }

  /**
   * Quick malware check (hash lookup only)
   */
  static async quickCheck(fileHash: string): Promise<{
    isMalicious: boolean;
    source?: string;
  }> {
    // Check against VirusTotal without uploading
    const vtResult = await VirusTotalFileService.checkHash(fileHash);

    if (vtResult && vtResult.isMalicious) {
      return {
        isMalicious: true,
        source: 'VirusTotal',
      };
    }

    return {
      isMalicious: false,
    };
  }
}
