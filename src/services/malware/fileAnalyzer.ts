/**
 * File Malware Analysis Service
 * Comprehensive file scanning with multiple detection techniques
 */

import crypto from 'crypto';
import { prisma } from '@/lib/prisma';
import { ThreatLevel } from '@prisma/client';

export interface FileAnalysisResult {
  fileHash: {
    md5: string;
    sha1: string;
    sha256: string;
    ssdeep?: string;
  };
  isMalicious: boolean;
  malwareFamily?: string;
  threatLevel: ThreatLevel;
  confidence: number; // 0-100
  riskScore: number; // 0-100
  indicators: string[];
  detections: {
    signatureMatches: number;
    behavioralFlags: number;
    externalEngines: number;
  };
  properties: {
    isPacked: boolean;
    isObfuscated: boolean;
    isEncrypted: boolean;
    hasSuspiciousAPI: boolean;
  };
  recommendations: string[];
  scanDuration: number;
}

export class FileAnalyzer {
  /**
   * Analyze file buffer for malware
   */
  static async analyzeFile(
    fileBuffer: Buffer,
    fileName: string,
    userId?: string
  ): Promise<FileAnalysisResult> {
    const startTime = Date.now();
    const indicators: string[] = [];
    let riskScore = 0;

    // Calculate file hashes
    const hashes = this.calculateHashes(fileBuffer);

    // Check if file already analyzed (cache lookup)
    const existingAnalysis = await this.getCachedAnalysis(hashes.sha256);
    if (existingAnalysis && this.isCacheValid(existingAnalysis.lastScanned)) {
      return this.buildResultFromCache(existingAnalysis, Date.now() - startTime);
    }

    // Check against threat feeds
    const threatFeedMatch = await this.checkThreatFeeds(hashes);
    if (threatFeedMatch) {
      indicators.push(`File hash found in threat intelligence feed: ${threatFeedMatch.source}`);
      riskScore += 80;
    }

    // Get file metadata
    const fileSize = fileBuffer.length;
    const fileType = this.detectFileType(fileBuffer);
    const fileExtension = this.extractExtension(fileName);

    // Signature-based detection
    const signatureMatches = await this.scanWithSignatures(fileBuffer, fileType);
    if (signatureMatches.length > 0) {
      indicators.push(`Matched ${signatureMatches.length} malware signatures`);
      riskScore += Math.min(signatureMatches.length * 20, 60);
    }

    // Static analysis
    const staticAnalysis = this.performStaticAnalysis(fileBuffer, fileType);
    indicators.push(...staticAnalysis.indicators);
    riskScore += staticAnalysis.riskScore;

    // Suspicious file patterns
    const suspiciousPatterns = this.detectSuspiciousPatterns(fileBuffer, fileName);
    indicators.push(...suspiciousPatterns.indicators);
    riskScore += suspiciousPatterns.riskScore;

    // File property analysis
    const properties = {
      isPacked: staticAnalysis.isPacked,
      isObfuscated: staticAnalysis.isObfuscated,
      isEncrypted: staticAnalysis.isEncrypted,
      hasSuspiciousAPI: staticAnalysis.hasSuspiciousAPI,
    };

    // Determine threat level and malware family
    const threatLevel = this.determineThreatLevel(riskScore);
    const isMalicious = riskScore >= 60;
    const malwareFamily = this.identifyMalwareFamily(signatureMatches, staticAnalysis);

    // Calculate confidence
    const confidence = this.calculateConfidence(
      signatureMatches.length,
      staticAnalysis.confidence,
      threatFeedMatch ? 100 : 0
    );

    // Generate recommendations
    const recommendations = this.generateRecommendations(
      threatLevel,
      isMalicious,
      properties
    );

    const scanDuration = Date.now() - startTime;

    const result: FileAnalysisResult = {
      fileHash: hashes,
      isMalicious,
      malwareFamily,
      threatLevel,
      confidence,
      riskScore: Math.min(riskScore, 100),
      indicators,
      detections: {
        signatureMatches: signatureMatches.length,
        behavioralFlags: staticAnalysis.behavioralFlags,
        externalEngines: 0, // Updated by external services
      },
      properties,
      recommendations,
      scanDuration,
    };

    // Save analysis to database
    await this.saveAnalysis(result, fileName, fileSize, fileType, fileExtension, userId);

    return result;
  }

  /**
   * Calculate file hashes (MD5, SHA1, SHA256)
   */
  private static calculateHashes(buffer: Buffer): {
    md5: string;
    sha1: string;
    sha256: string;
  } {
    return {
      md5: crypto.createHash('md5').update(buffer).digest('hex'),
      sha1: crypto.createHash('sha1').update(buffer).digest('hex'),
      sha256: crypto.createHash('sha256').update(buffer).digest('hex'),
    };
  }

  /**
   * Check file hashes against threat intelligence feeds
   */
  private static async checkThreatFeeds(hashes: any) {
    const feeds = await prisma.malwareThreatFeed.findMany({
      where: {
        AND: [
          { isActive: true },
          { isFalsePositive: false },
          {
            OR: [
              { indicatorType: 'FILE_HASH', indicatorValue: hashes.md5 },
              { indicatorType: 'FILE_HASH', indicatorValue: hashes.sha1 },
              { indicatorType: 'FILE_HASH', indicatorValue: hashes.sha256 },
            ],
          },
        ],
      },
      take: 1,
    });

    return feeds[0] || null;
  }

  /**
   * Scan file against malware signatures
   */
  private static async scanWithSignatures(buffer: Buffer, fileType: string) {
    const signatures = await prisma.malwareSignature.findMany({
      where: {
        isActive: true,
      },
    });

    const matches: any[] = [];

    for (const signature of signatures) {
      const isMatch = this.matchSignature(buffer, signature);
      if (isMatch) {
        matches.push(signature);

        // Update detection count
        await prisma.malwareSignature.update({
          where: { id: signature.id },
          data: {
            detectionCount: { increment: 1 },
            lastDetection: new Date(),
          },
        });
      }
    }

    return matches;
  }

  /**
   * Match buffer against a signature
   */
  private static matchSignature(buffer: Buffer, signature: any): boolean {
    const bufferHex = buffer.toString('hex');
    const bufferStr = buffer.toString('utf8');

    try {
      switch (signature.type) {
        case 'HASH':
          // Hash matching is done in threat feed check
          return false;

        case 'REGEX':
          const regex = new RegExp(signature.pattern, signature.caseSensitive ? '' : 'i');
          return regex.test(bufferStr);

        case 'BYTE_PATTERN':
          return bufferHex.includes(signature.pattern.toLowerCase());

        case 'YARA':
          // YARA rules would require yara library integration
          // For now, return false
          return false;

        default:
          return false;
      }
    } catch (error) {
      console.error('Signature matching error:', error);
      return false;
    }
  }

  /**
   * Perform static file analysis
   */
  private static performStaticAnalysis(buffer: Buffer, fileType: string) {
    const indicators: string[] = [];
    let riskScore = 0;
    let confidence = 50;
    let behavioralFlags = 0;

    const fileStr = buffer.toString('utf8');
    const fileHex = buffer.toString('hex');

    // Check for packing (high entropy)
    const entropy = this.calculateEntropy(buffer);
    const isPacked = entropy > 7.0; // High entropy suggests packing/encryption
    if (isPacked) {
      indicators.push('File appears to be packed or compressed');
      riskScore += 15;
      behavioralFlags++;
    }

    // Check for obfuscation
    const isObfuscated = this.detectObfuscation(fileStr);
    if (isObfuscated) {
      indicators.push('Code obfuscation detected');
      riskScore += 20;
      behavioralFlags++;
    }

    // Check for encryption markers
    const isEncrypted = this.detectEncryption(buffer, fileHex);
    if (isEncrypted) {
      indicators.push('Encryption detected in file');
      riskScore += 10;
    }

    // Detect suspicious API calls (Windows)
    const hasSuspiciousAPI = this.detectSuspiciousAPIs(fileStr);
    if (hasSuspiciousAPI) {
      indicators.push('Suspicious API calls detected');
      riskScore += 25;
      behavioralFlags++;
    }

    // Check for executable in non-executable format
    if (this.isExecutableInDisguise(buffer, fileType)) {
      indicators.push('Executable code found in non-executable file');
      riskScore += 30;
      behavioralFlags++;
    }

    confidence = Math.min(50 + (behavioralFlags * 10), 95);

    return {
      indicators,
      riskScore,
      confidence,
      behavioralFlags,
      isPacked,
      isObfuscated,
      isEncrypted,
      hasSuspiciousAPI,
    };
  }

  /**
   * Calculate Shannon entropy (0-8)
   */
  private static calculateEntropy(buffer: Buffer): number {
    const freq: { [key: number]: number } = {};

    // Count byte frequencies
    for (let i = 0; i < buffer.length; i++) {
      const byte = buffer[i];
      freq[byte] = (freq[byte] || 0) + 1;
    }

    // Calculate entropy
    let entropy = 0;
    const len = buffer.length;

    for (const byte in freq) {
      const p = freq[byte] / len;
      entropy -= p * Math.log2(p);
    }

    return entropy;
  }

  /**
   * Detect code obfuscation
   */
  private static detectObfuscation(content: string): boolean {
    // Check for common obfuscation patterns
    const obfuscationPatterns = [
      /eval\s*\(/gi,
      /\\x[0-9a-f]{2}/gi, // Hex encoding
      /\\u[0-9a-f]{4}/gi, // Unicode encoding
      /fromCharCode/gi,
      /unescape/gi,
      /atob/gi, // Base64 decode
      /String\.fromCodePoint/gi,
    ];

    for (const pattern of obfuscationPatterns) {
      if (pattern.test(content)) {
        return true;
      }
    }

    // Check for excessive base64
    const base64Count = (content.match(/[A-Za-z0-9+/=]{50,}/g) || []).length;
    if (base64Count > 5) {
      return true;
    }

    return false;
  }

  /**
   * Detect encryption markers
   */
  private static detectEncryption(buffer: Buffer, hex: string): boolean {
    // Check for cryptographic headers
    const cryptoMarkers = [
      '504b0304', // ZIP header
      '526172211a', // RAR header
      '1f8b08', // GZIP header
      '425a68', // BZIP2 header
      '377abcaf', // 7-Zip header
    ];

    for (const marker of cryptoMarkers) {
      if (hex.startsWith(marker)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Detect suspicious Windows API calls
   */
  private static detectSuspiciousAPIs(content: string): boolean {
    const suspiciousAPIs = [
      'VirtualAlloc',
      'VirtualProtect',
      'CreateRemoteThread',
      'WriteProcessMemory',
      'OpenProcess',
      'SetWindowsHookEx',
      'GetProcAddress',
      'LoadLibrary',
      'WinExec',
      'ShellExecute',
      'URLDownloadToFile',
      'InternetReadFile',
      'CreateProcess',
      'RegSetValue',
      'RegDeleteKey',
    ];

    let suspiciousCount = 0;
    for (const api of suspiciousAPIs) {
      if (content.includes(api)) {
        suspiciousCount++;
      }
    }

    // Threshold: 3 or more suspicious APIs
    return suspiciousCount >= 3;
  }

  /**
   * Check if executable hidden in non-executable format
   */
  private static isExecutableInDisguise(buffer: Buffer, declaredType: string): boolean {
    const hex = buffer.toString('hex', 0, Math.min(buffer.length, 100));

    // PE executable header
    if (hex.includes('4d5a') && !declaredType.includes('executable')) {
      return true;
    }

    // ELF executable header
    if (hex.startsWith('7f454c46') && !declaredType.includes('executable')) {
      return true;
    }

    return false;
  }

  /**
   * Detect suspicious file patterns
   */
  private static detectSuspiciousPatterns(buffer: Buffer, fileName: string) {
    const indicators: string[] = [];
    let riskScore = 0;

    // Double extension (e.g., .pdf.exe)
    if (/\.[a-z]{3,4}\.[a-z]{3,4}$/i.test(fileName)) {
      indicators.push('Double file extension detected');
      riskScore += 25;
    }

    // Suspicious extensions
    const suspiciousExts = ['.scr', '.pif', '.bat', '.cmd', '.vbs', '.js', '.jar', '.msi'];
    if (suspiciousExts.some(ext => fileName.toLowerCase().endsWith(ext))) {
      indicators.push('Potentially dangerous file extension');
      riskScore += 15;
    }

    // Very long filename (> 200 chars)
    if (fileName.length > 200) {
      indicators.push('Unusually long filename');
      riskScore += 10;
    }

    return { indicators, riskScore };
  }

  /**
   * Detect file type from magic bytes
   */
  private static detectFileType(buffer: Buffer): string {
    const hex = buffer.toString('hex', 0, Math.min(buffer.length, 20));

    const signatures: { [key: string]: string } = {
      '89504e47': 'image/png',
      'ffd8ffe0': 'image/jpeg',
      'ffd8ffe1': 'image/jpeg',
      '25504446': 'application/pdf',
      '504b0304': 'application/zip',
      '4d5a9000': 'application/x-msdownload', // PE executable
      '7f454c46': 'application/x-executable', // ELF executable
      'd0cf11e0': 'application/vnd.ms-office', // MS Office
    };

    for (const [magic, type] of Object.entries(signatures)) {
      if (hex.startsWith(magic)) {
        return type;
      }
    }

    return 'application/octet-stream';
  }

  /**
   * Extract file extension
   */
  private static extractExtension(fileName: string): string {
    const match = fileName.match(/\.([^.]+)$/);
    return match ? match[1].toLowerCase() : '';
  }

  /**
   * Identify malware family from signatures
   */
  private static identifyMalwareFamily(signatures: any[], staticAnalysis: any): string | undefined {
    if (signatures.length > 0) {
      // Get the most severe signature match
      const sorted = signatures.sort((a, b) => {
        const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'SAFE'];
        return severityOrder.indexOf(a.severity) - severityOrder.indexOf(b.severity);
      });

      return sorted[0].malwareFamily || sorted[0].category;
    }

    return undefined;
  }

  /**
   * Calculate confidence score
   */
  private static calculateConfidence(
    signatureMatches: number,
    staticConfidence: number,
    threatFeedConfidence: number
  ): number {
    let confidence = 0;

    // Signature matches boost confidence
    confidence += Math.min(signatureMatches * 20, 40);

    // Static analysis confidence
    confidence += staticConfidence * 0.3;

    // Threat feed is very confident
    if (threatFeedConfidence > 0) {
      confidence = Math.max(confidence, 90);
    }

    return Math.min(Math.round(confidence), 100);
  }

  /**
   * Determine threat level from risk score
   */
  private static determineThreatLevel(riskScore: number): ThreatLevel {
    if (riskScore >= 80) return 'CRITICAL';
    if (riskScore >= 60) return 'HIGH';
    if (riskScore >= 40) return 'MEDIUM';
    if (riskScore >= 20) return 'LOW';
    return 'SAFE';
  }

  /**
   * Generate recommendations
   */
  private static generateRecommendations(
    threatLevel: ThreatLevel,
    isMalicious: boolean,
    properties: any
  ): string[] {
    const recommendations: string[] = [];

    if (threatLevel === 'CRITICAL') {
      recommendations.push('CRITICAL THREAT: Delete this file immediately');
      recommendations.push('Do NOT execute or open this file');
      recommendations.push('Scan your system with updated antivirus software');
      recommendations.push('Change passwords if this file was opened');
    } else if (threatLevel === 'HIGH') {
      recommendations.push('HIGH RISK: Quarantine this file');
      recommendations.push('Do not execute without expert analysis');
      recommendations.push('Consider submitting to VirusTotal for verification');
    } else if (threatLevel === 'MEDIUM') {
      recommendations.push('Exercise caution with this file');
      recommendations.push('Verify the source before opening');
      recommendations.push('Scan in a sandboxed environment if possible');
    } else if (threatLevel === 'LOW') {
      recommendations.push('Low risk detected - proceed with normal caution');
      recommendations.push('Verify file source and authenticity');
    } else {
      recommendations.push('File appears safe');
      recommendations.push('Always verify file sources');
    }

    if (properties.isPacked) {
      recommendations.push('File is packed - may be legitimate software or malware');
    }

    if (properties.isObfuscated) {
      recommendations.push('Code obfuscation detected - unusual for legitimate software');
    }

    return recommendations;
  }

  /**
   * Get cached analysis
   */
  private static async getCachedAnalysis(sha256: string) {
    return await prisma.fileAnalysis.findUnique({
      where: { sha256 },
      include: { signatures: true },
    });
  }

  /**
   * Check if cache is valid (7 days)
   */
  private static isCacheValid(lastScanned: Date): boolean {
    const now = new Date();
    const age = now.getTime() - lastScanned.getTime();
    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
    return age < maxAge;
  }

  /**
   * Build result from cached analysis
   */
  private static buildResultFromCache(cached: any, scanDuration: number): FileAnalysisResult {
    return {
      fileHash: {
        md5: cached.md5,
        sha1: cached.sha1,
        sha256: cached.sha256,
        ssdeep: cached.ssdeep || undefined,
      },
      isMalicious: cached.isMalicious,
      malwareFamily: cached.malwareFamily || undefined,
      threatLevel: cached.threatLevel,
      confidence: cached.confidence,
      riskScore: cached.riskScore,
      indicators: cached.indicators,
      detections: {
        signatureMatches: cached.signatures.length,
        behavioralFlags: cached.indicators.length,
        externalEngines: cached.virusTotalDetections,
      },
      properties: {
        isPacked: cached.isPacked,
        isObfuscated: cached.isObfuscated,
        isEncrypted: cached.isEncrypted,
        hasSuspiciousAPI: cached.hasSuspiciousAPI,
      },
      recommendations: [], // Generate fresh recommendations
      scanDuration,
    };
  }

  /**
   * Save analysis to database
   */
  private static async saveAnalysis(
    result: FileAnalysisResult,
    fileName: string,
    fileSize: number,
    fileType: string,
    fileExtension: string,
    userId?: string
  ): Promise<void> {
    try {
      await prisma.fileAnalysis.create({
        data: {
          userId,
          fileName,
          fileSize,
          fileType,
          fileExtension,
          md5: result.fileHash.md5,
          sha1: result.fileHash.sha1,
          sha256: result.fileHash.sha256,
          ssdeep: result.fileHash.ssdeep,
          isMalicious: result.isMalicious,
          malwareFamily: result.malwareFamily,
          threatLevel: result.threatLevel,
          confidence: result.confidence,
          riskScore: result.riskScore,
          detectionNames: [],
          indicators: result.indicators,
          tags: [],
          isPacked: result.properties.isPacked,
          isObfuscated: result.properties.isObfuscated,
          isEncrypted: result.properties.isEncrypted,
          hasSuspiciousAPI: result.properties.hasSuspiciousAPI,
          virusTotalDetections: result.detections.externalEngines,
          virusTotalEngines: 0,
        },
      });
    } catch (error) {
      console.error('Failed to save file analysis:', error);
    }
  }
}
